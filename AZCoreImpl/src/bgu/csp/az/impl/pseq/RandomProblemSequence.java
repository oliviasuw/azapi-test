/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package bgu.csp.az.impl.pseq;

import bgu.csp.az.impl.prob.MatrixProblem;
import bgu.csp.az.api.Problem;
import bgu.csp.az.api.ProblemView;
import bgu.csp.az.api.pseq.ProblemBuilder;
import bgu.csp.az.api.pseq.ProblemSequence;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Random;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author bennyl
 */
public class RandomProblemSequence implements ProblemSequence {
    public static final String DESCRIPTION_PROBLEM_METADATA = "Description";
    public static final String MAX_COST_PROBLEM_METADATA = "Max Cost";
    public static final String P1_PROBLEM_METADATA = "Probability Of Constraint Between Two Variables";
    public static final String P2_PROBLEM_METADATA = "Probability Of Conflict Between Two Constrained Variables";
    
    private Class probType;
    private Random rnd;
    float p1;
    float p2;
    int maxCost;
    int n;
    int d;
    int numberOfProblems;
    ProblemBuilder probBuilder;

    public RandomProblemSequence(float p1, float p2, int maxCost, int n, int d, long seed, int numberOfProblems,  ProblemBuilder probBuilder, Class probType) {
        this.p1 = p1;
        this.p2 = p2;
        this.maxCost = maxCost;
        this.n = n;
        this.d = d;
        this.rnd = new Random(seed);
        this.numberOfProblems = numberOfProblems;
        this.probBuilder = probBuilder;
        this.probType = probType;
    }

    public RandomProblemSequence(Configuration sd) {
        this.p1 = sd.getP1();
        this.p2 = sd.getP2();
        this.maxCost = sd.getMaxCost();
        this.n = sd.getNumberOfVariables();
        this.d = sd.getDomainSize();
        this.rnd = new Random(sd.getSeed());
        this.numberOfProblems = sd.getProblemsAmount();
        }

    @Override
    public Problem next() {
        numberOfProblems--;
        
        final Problem problem = probBuilder.build();
        if (probType == MatrixProblem.class){
            for (int i = 0; i < problem.getNumvars(); i++) {
                for (int j = i + 1; j < problem.getNumvars(); j++) {
                    if (rnd.nextDouble() < p1) {
                        buildConstraint(i, j, problem, true);
                    }
                }
            }
        }else{
            for (int i = 0; i < problem.getNumvars(); i++) {
                for (int j = 0; j < problem.getNumvars(); j++) {
                    if (rnd.nextDouble() < p1) {
                        buildConstraint(i, j, problem, false);
                    }
                }
            }
        }
        
        final HashMap<String, Object> metadata = problem.getMetadata();
        metadata.put(P1_PROBLEM_METADATA, p1);
        metadata.put(P2_PROBLEM_METADATA, p2);
        metadata.put(MAX_COST_PROBLEM_METADATA, maxCost);
        metadata.put(DESCRIPTION_PROBLEM_METADATA, "AutoGenerated Random Problem");

        return problem;

    }

    private void buildConstraint(int i, int j, Problem p, boolean sym) {
        for (int vi = 0; vi < p.getDomain().size(); vi++) {
            for (int vj = 0; vj < p.getDomain().size(); vj++) {
                if (rnd.nextDouble() < p2) {
                    final int cost = rnd.nextInt(maxCost) + 1;
                    p.setConstraintCost(i, vi, j, vj, cost);
                    if (sym)
                        p.setConstraintCost(j, vj, i, vi, cost);
                }
            }
        }
    }

    @Override
    public boolean hasNext() {
        return numberOfProblems > 0;
    }

    public static class Configuration implements Serializable {

        private float p1;
        private float p2;
        private int maxCost;
        private int n;
        private int d;
        private int nprob;
        private long seed;

        public Configuration(float p1, float p2, int maxCost, int n, int d, int nprob, long seed) {
            this.p1 = p1;
            this.p2 = p2;
            this.maxCost = maxCost;
            this.n = n;
            this.d = d;
            this.nprob = nprob;
            this.seed = seed;
        }

        public int getDomainSize() {
            return d;
        }

        public int getMaxCost() {
            return maxCost;
        }

        public int getNumberOfVariables() {
            return n;
        }

        public int getProblemsAmount() {
            return nprob;
        }

        public float getP1() {
            return p1;
        }

        public float getP2() {
            return p2;
        }

        public long getSeed() {
            return seed;
        }

        public void setD(int d) {
            this.d = d;
        }

        public void setMaxCost(int maxCost) {
            this.maxCost = maxCost;
        }

        public void setN(int n) {
            this.n = n;
        }

        public void setNprob(int nprob) {
            this.nprob = nprob;
        }

        public void setP1(float p1) {
            this.p1 = p1;
        }

        public void setP2(float p2) {
            this.p2 = p2;
        }

        public void setSeed(long seed) {
            this.seed = seed;
        }
    }
}

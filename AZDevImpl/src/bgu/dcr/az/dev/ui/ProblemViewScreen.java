/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * StatusScreen.java
 *
 * Created on 24/11/2011, 16:25:11
 */
package bgu.dcr.az.dev.ui;

import bc.dsl.SwingDSL;
import bc.ui.swing.consoles.ConstraintCalcConsole.ConstraintShowListener;
import bc.ui.swing.trees.IconProvider;
import bgu.dcr.az.api.ImmutableProblem;
import bgu.dcr.az.api.infra.Execution;
import bgu.dcr.az.api.infra.Experiment;
import bgu.dcr.az.api.infra.Round;
import bgu.dcr.az.impl.pgen.MapProblem;
import bgu.dcr.az.impl.pgen.UnstructuredDCOPGen;
import java.util.Enumeration;
import java.util.Random;
import javax.swing.Icon;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

/**
 *
 * @author bennyl
 */
public class ProblemViewScreen extends javax.swing.JPanel implements ConstraintShowListener, Experiment.ExperimentListener {

    public static final String CONSTRAINT_MATRIX = "Constraints Matrix";
    
    /** Creates new form StatusScreen */
    @SuppressWarnings("LeakingThisInConstructor")
    public ProblemViewScreen(ImmutableProblem p) {
        initComponents();
        prepareTree(p);
        tree.setIconProvider(new IconProvider() {

            private Icon AGENT1_ICON = SwingDSL.resIcon("agent1");
            private Icon AGENT2_ICON = SwingDSL.resIcon("agent2");
            private Icon ALL_ICON = SwingDSL.resIcon("all-constraints");
            private Icon PROBLEM_ICON = SwingDSL.resIcon("problem");
            

            @Override
            public Icon provideFor(Object item) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) item;
                if (node.isLeaf()) {
                    if (((AgentInfo) node.getUserObject()).getName().equals(CONSTRAINT_MATRIX)) {
                        return ALL_ICON;
                    } else {
                        return AGENT2_ICON;
                    }
                } else if (node.isRoot()){
                    return PROBLEM_ICON;
                }else{
                    return AGENT1_ICON;
                }
            }
        });

        calc.addListener(this);
        calc.setProblem(p);
        problemChangePan.setVisible(false);
    }

    private void prepareTree(final ImmutableProblem p) {


        DefaultMutableTreeNode r = (DefaultMutableTreeNode) tree.getModel().getRoot();
        r.removeAllChildren();
        r.setUserObject(new AgentInfo("Problem"));
        final DefaultMutableTreeNode node = new DefaultMutableTreeNode(new AgentInfo(CONSTRAINT_MATRIX), true);
        r.add(node);
        System.out.println(r.getIndex(node));
        loadAgents(r, p);

        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);

        //Listen for when the selection changes.
        tree.addTreeSelectionListener(new TreeSelectionListener() {

            @Override
            public void valueChanged(TreeSelectionEvent e) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();
                System.out.println(node);
                TreePath selectionPath = tree.getSelectionPath();
                System.out.println(selectionPath.toString());

                if (node == null) { //Nothing is selected.
                    return;
                }
                Object nodeInfo = node.getUserObject();
                DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) node.getParent();
                if (node.isLeaf()) {
                    AgentInfo agent = (AgentInfo) nodeInfo;
                    if (agent.getName().equals(CONSTRAINT_MATRIX)) {
                        prepareAll(p);
                    } else if (parentNode == tree.getModel().getRoot()) {
                        dataPane.unSetData();
                    } else {

                        Object parentInfo = parentNode.getUserObject();
                        AgentInfo parent = (AgentInfo) parentInfo;
                        prepareConstraints(parent.getId(), agent.getId(), p);
                    }
                } else {
                    dataPane.unSetData();
                }
            }
        });
        dataPane.unSetData();
        tree.updateUI();

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        constraintsTable = new bc.ui.swing.tables.ConstraintTable();
        jPanel1 = new javax.swing.JPanel();
        jPanel11 = new javax.swing.JPanel();
        problemViewingDescription = new javax.swing.JLabel();
        jXHyperlink1 = new org.jdesktop.swingx.JXHyperlink();
        problemChangePan = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jComboBox1 = new javax.swing.JComboBox();
        jLabel2 = new javax.swing.JLabel();
        jSpinner1 = new javax.swing.JSpinner();
        jButton1 = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        tree = new bc.ui.swing.trees.ScrollableStripeTree();
        dataPane = new bc.ui.swing.useful.DataPanel();
        calc = new bc.ui.swing.consoles.ConstraintCalcConsole();

        setOpaque(false);
        setLayout(new java.awt.BorderLayout());

        jPanel1.setBackground(new java.awt.Color(120, 120, 120));
        jPanel1.setLayout(new java.awt.GridBagLayout());

        jPanel11.setBackground(new java.awt.Color(120, 120, 120));
        jPanel11.setLayout(new java.awt.GridBagLayout());

        problemViewingDescription.setFont(new java.awt.Font("Consolas", 1, 14)); // NOI18N
        problemViewingDescription.setForeground(new java.awt.Color(255, 255, 255));
        problemViewingDescription.setText("Viewing Problem X of Round Y");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);
        jPanel11.add(problemViewingDescription, gridBagConstraints);

        jXHyperlink1.setForeground(new java.awt.Color(210, 233, 255));
        jXHyperlink1.setText("change?");
        jXHyperlink1.setClickedColor(new java.awt.Color(210, 233, 255));
        jXHyperlink1.setFont(new java.awt.Font("Consolas", 1, 12)); // NOI18N
        jXHyperlink1.setUnclickedColor(new java.awt.Color(210, 233, 255));
        jXHyperlink1.setVerifyInputWhenFocusTarget(false);
        jXHyperlink1.setVerticalAlignment(javax.swing.SwingConstants.BOTTOM);
        jXHyperlink1.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jXHyperlink1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jXHyperlink1ActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 3);
        jPanel11.add(jXHyperlink1, gridBagConstraints);

        problemChangePan.setOpaque(false);
        problemChangePan.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        jLabel1.setFont(new java.awt.Font("Consolas", 0, 12)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 255, 255));
        jLabel1.setText("Round");
        problemChangePan.add(jLabel1);

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        problemChangePan.add(jComboBox1);

        jLabel2.setFont(new java.awt.Font("Consolas", 0, 12)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(255, 255, 255));
        jLabel2.setText(", Problem Number");
        problemChangePan.add(jLabel2);

        jSpinner1.setPreferredSize(new java.awt.Dimension(50, 20));
        problemChangePan.add(jSpinner1);

        jButton1.setText("View");
        jButton1.setOpaque(false);
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        problemChangePan.add(jButton1);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        jPanel11.add(problemChangePan, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 0);
        jPanel1.add(jPanel11, gridBagConstraints);

        jPanel3.setOpaque(false);
        jPanel3.setLayout(new java.awt.GridBagLayout());

        tree.setBorder(javax.swing.BorderFactory.createMatteBorder(0, 0, 0, 3, new java.awt.Color(102, 102, 102)));
        tree.setMinimumSize(new java.awt.Dimension(200, 22));
        tree.setPreferredSize(new java.awt.Dimension(200, 440));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weighty = 1.0;
        jPanel3.add(tree, gridBagConstraints);

        dataPane.setBackground(new java.awt.Color(153, 153, 153));
        dataPane.setForeground(new java.awt.Color(255, 255, 255));
        dataPane.setNoDataForeColor(new java.awt.Color(255, 255, 255));
        dataPane.setNoDataText("No Constraint Table To Show");
        dataPane.setOpaque(true);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        jPanel3.add(dataPane, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        jPanel3.add(calc, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 3, 3);
        jPanel1.add(jPanel3, gridBagConstraints);

        add(jPanel1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    private void jXHyperlink1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jXHyperlink1ActionPerformed
        problemChangePan.setVisible(true);
    }//GEN-LAST:event_jXHyperlink1ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        problemChangePan.setVisible(false);
    }//GEN-LAST:event_jButton1ActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private bc.ui.swing.consoles.ConstraintCalcConsole calc;
    private bc.ui.swing.tables.ConstraintTable constraintsTable;
    private bc.ui.swing.useful.DataPanel dataPane;
    private javax.swing.JButton jButton1;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel11;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JSpinner jSpinner1;
    private org.jdesktop.swingx.JXHyperlink jXHyperlink1;
    private javax.swing.JPanel problemChangePan;
    private javax.swing.JLabel problemViewingDescription;
    private bc.ui.swing.trees.ScrollableStripeTree tree;
    // End of variables declaration//GEN-END:variables

    private void loadAgents(DefaultMutableTreeNode r, ImmutableProblem p) {
        int varNum = p.getNumberOfVariables();
        for (int i = 0; i < varNum; i++) {
            DefaultMutableTreeNode node = new DefaultMutableTreeNode(new AgentInfo(i), true);
            for (Integer j : p.getNeighbors(i)) {
                final DefaultMutableTreeNode child = new DefaultMutableTreeNode(new AgentInfo(j), false);
                node.add(child);
//                System.out.println("index of agent " + j + " is " + node.getIndex(child));
            }
            r.add(node);
//            System.out.println("index of agent " + i + " is " + r.getIndex(node));
        }
    }

    private void prepareAll(ImmutableProblem p) {
        int numVars = p.getNumberOfVariables();
        DefaultTableModel model = new DefaultTableModel();
        model.setColumnCount(numVars + 1);
        model.setRowCount(numVars + 1);
        for (int i = 0; i < numVars; i++) {
            model.setValueAt(i, 0, i + 1);
        }
        for (int j = 0; j < numVars; j++) {
            model.setValueAt(j, j + 1, 0);
            for (int i = 0; i < numVars; i++) {
                if (p.isConstrained(i, j)) {
                    model.setValueAt(1, j + 1, i + 1);
                } else {
                    model.setValueAt(0, j + 1, i + 1);
                }
            }
        }
        this.constraintsTable.getTable().setModel(model);
        this.constraintsTable.getTable().setTableHeader(null);
//        this.constraintsTablePane.setColumnHeaderView(null);
        this.dataPane.setData(constraintsTable);
        this.constraintsTable.updateUI();

    }

    private void prepareConstraints(int ai, int aj, ImmutableProblem p) {
        int domVars = p.getDomainSize(ai);
        DefaultTableModel model = new DefaultTableModel();
        model.setColumnCount(domVars + 1);
        model.setRowCount(domVars + 1);
        String name = "" + ai + " / " + aj;
        model.setValueAt(name, 0, 0);
        for (int i = 0; i < domVars; i++) {
            model.setValueAt(i, 0, i + 1);
        }
        for (int j = 0; j < domVars; j++) {
            model.setValueAt(j, j + 1, 0);
            for (int i = 0; i < domVars; i++) {
                int cost = (int) p.getConstraintCost(ai, i, aj, j);
                model.setValueAt(cost, j + 1, i + 1);
            }
        }

        this.constraintsTable.getTable().setModel(model);
        this.constraintsTable.getTable().setTableHeader(
                null);


//        this.constraintsTable.setColumnHeaderView(null);
        this.dataPane.setData(constraintsTable);


        this.constraintsTable.getTable().updateUI();
    }

    public static void main(String[] args) {
        MapProblem p = new MapProblem();
        final UnstructuredDCOPGen gen = new UnstructuredDCOPGen();
        gen.bubbleDownVariable("n", 12);
        gen.bubbleDownVariable("d", 7);
        gen.generate(p, new Random());
        SwingDSL.configureUI();
        SwingDSL.showInFrame(new ProblemViewScreen(p));
    }

    @Override
    public boolean onConstraintShowRequested(int i, int j) {
        DefaultMutableTreeNode root = (DefaultMutableTreeNode) tree.getModel().getRoot();
        Enumeration parents = root.children();
        while (parents.hasMoreElements()) {
            DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) parents.nextElement();
            if (((AgentInfo) parentNode.getUserObject()).getId() == i) {
                Enumeration children = parentNode.children();
                while (children.hasMoreElements()) {
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
                    if (((AgentInfo) node.getUserObject()).getId() == j) {
                        TreePath treePath = new TreePath(new Object[]{root, parentNode, node});
//                        System.out.println(treePath.toString());
                        tree.setSelectionPath(treePath);
                        tree.expandPath(treePath);
                        return true;
                    }
                }
            }
        }
        return false;
    }

    @Override
    public void onExpirementStarted(Experiment source) {
//        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void onExpirementEnded(Experiment source) {
//        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void onNewRoundStarted(Experiment source, Round round) {
//        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void onNewExecutionStarted(Experiment source, Round round, Execution exec) {
//        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void onExecutionEnded(Experiment source, Round round, Execution exec) {
//        throw new UnsupportedOperationException("Not supported yet.");
    }

    private static class AgentInfo {

        private final String name;
        private final int id;

        public AgentInfo(int id) {
            this.id = id;
            this.name = "Agent " + id;
        }

        public AgentInfo(String name) {
            this.name = name;
            this.id = -1;
        }

        @Override
        public String toString() {
            return this.name;
        }

        public int getId() {
            return id;
        }

        public String getName() {
            return name;
        }
    }
}

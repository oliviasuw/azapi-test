@code{
    regA = "bgu.dcr.az.conf.registery.Register";

    def propertyRequestedName(p){
        rname = p.javadoc.tag("propertyName");
        if (rname.isEmpty()){
            return p.name;
        }
        return rname.get(0);
    }
    
    super = lookupSuperClassWithAnnotation(regA);
    if (super == null) {
        super = "AbstractConfiguration";
    } else {
        super = super.underscoredFQN;
    }
}

package bgu.dcr.az.conf.autogen;

import bgu.dcr.az.conf.AbstractConfiguration;
import bgu.dcr.az.conf.PropertyImpl;
import bgu.dcr.az.conf.api.JavaDocInfo;
import bgu.dcr.az.conf.api.TypeInfo;
import bgu.dcr.az.conf.registery.Registery;
import bgu.dcr.az.conf.utils.JavaDocParser;
import bgu.dcr.az.conf.utils.JavaTypeParser;
import com.esotericsoftware.reflectasm.ConstructorAccess;
import com.esotericsoftware.reflectasm.MethodAccess;
import bgu.dcr.az.conf.registery.RegistrationMarker;

public class @{underscoredFQN} extends @{super} implements RegistrationMarker{
    
    //store type info for each property
    @foreach{p : properties}public static final TypeInfo @{p.name.toUpperCase()}_TYPE = JavaTypeParser.parse("@{p.type}");@end{"\n    "}
    
    //store javadoc for each property
    @foreach{p : properties}public static final JavaDocInfo @{p.name.toUpperCase()}_DOC = JavaDocParser.parse("@{p.javadoc}");@end{"\n    "}

    //store configured class javadoc
    public static JavaDocInfo DOC = JavaDocParser.parse("@{javadoc}");

    //store accessors for fast access
    public static final MethodAccess METHOD_ACCESSOR = MethodAccess.get(@{getFQN()}.class);
    public static final ConstructorAccess CONSTRUCTOR_ACCESSOR = ConstructorAccess.get(@{getFQN()}.class);

    //store access index for me and each of my configurable parents properties
    @{
        sb = new StringBuilder();
        super = this;
        
        alreadyResolvedProperties = new java.util.HashSet();
        allProperties = new java.util.HashSet();

        while (super != null){
            for (prop : super.properties){
                propUCase = prop.name.toUpperCase();
                if (!alreadyResolvedProperties.contains(propUCase)){

                    alreadyResolvedProperties.add(propUCase);
                    allProperties.add(prop);

                    sb.append("public static final int ")
                        .append(prop.name.toUpperCase())
                        .append("_GIDX = METHOD_ACCESSOR.getIndex(\"get")
                        .append(prop.name)
                        .append("\");\n    ");

                    sb.append("public static final int ")
                        .append(prop.name.toUpperCase())
                        .append("_SIDX = ");

                    if (prop.readOnly){
                        sb.append("-1;\n    ");
                    }else {
                        sb.append("METHOD_ACCESSOR.getIndex(\"set")
                            .append(prop.name)
                            .append("\");\n    ");
                    }
                }
            }

            super = super.lookupSuperClassWithAnnotation(regA);
        }
        
        sb.toString();
    }

    //registration on class loading time
    static {
        Registery.get().register(@{getFQN()}.class, "@{getAnnotation("bgu.dcr.az.conf.registery.Register").value}");
    }

    public @{underscoredFQN}() {
        super.type = @{getFQN()}.class;
        super.javadoc = DOC;
        super.accessor = METHOD_ACCESSOR;
        super.cAccessor = CONSTRUCTOR_ACCESSOR;

        //insert all properties
        @foreach{p : allProperties}properties.put("@{propertyRequestedName(p)}", new PropertyImpl("@{propertyRequestedName(p)}", this, @{p.name.toUpperCase()}_TYPE, @{p.name.toUpperCase()}_DOC, @{p.name.toUpperCase()}_GIDX, @{p.name.toUpperCase()}_SIDX));@end{"\n        "}

        @if{!lookupFieldsWithAnnotation("bgu.dcr.az.conf.api.Variable").isEmpty()}scanVariables();@end{}
    }
    
}
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package bgu.dcr.az.pivot.model.impl;

import bgu.dcr.az.pivot.model.AggregatedField;
import bgu.dcr.az.pivot.model.Field;
import bgu.dcr.az.pivot.model.FilterField;
import bgu.dcr.az.pivot.model.Pivot;
import bgu.dcr.az.pivot.model.Table;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;

/**
 * Creates a pivot table according to provided pivot.
 * First all filtered initial rows deleted (according to
 * selected FilterFields). Next columns and rows calculated: 
 * -columns labels are all permutations of selected SeriesFields 
 * values X selected ValuesFields
 * -rows labels are all permutations of selected AxisFields values
 * Pay attention that the order of selected Series/Axis field matter.
 * Finally the inner data generated by extracting set of values 
 * (ValuesFields) and applying to it selected aggregation function.
 * @author Zovadi
 * @param <T> 
 */
public class InMemoryPivotTable<T> implements Table {

    private Object[][] columns;
    private Object[][] rows;
    private Object[][] data;

    /**
     * creates a pivot table (evaluated and stored in memory)
     * according to provided pivot
     * @param pivot 
     */
    public InMemoryPivotTable(Pivot<T> pivot) {
        generatePivotTableData(pivot);
    }

    @Override
    public Object[][] getColumnHeaders() {
        return columns;
    }

    @Override
    public Object[][] getRowHeaders() {
        return rows;
    }

    @Override
    public Object getCell(int column, int row) {
        return data[column][row];
    }

    /**
     * actually performs creation of a pivot table
     * an filling it with values according to provided
     * pivot {@see InMemoryPivotTable}
     * @param pivot 
     */
    private void generatePivotTableData(Pivot<T> pivot) {
        // the container for set of values for given fields
        Map<Field, Set<Object>> sets = new HashMap<>();

        // collecting set of all values for a given fields in order 
        // to generate permutations (rows/columns headers)
        for (T record : pivot.getDataRecords()) {
            if (!isRestrictedRecord(pivot, record)) {
                extractFieldsValues(pivot.getSelectedSeriesFields(), record, sets);
                extractFieldsValues(pivot.getSelectedAxisFields(), record, sets);
            }
        }

        // generating columns labels
        columns = permutateFieldsValues(pivot.getSelectedSeriesFields(), sets, pivot.getSelectedValuesFields());
        // generating rows labels
        rows = permutateFieldsValues(pivot.getSelectedAxisFields(), sets, Collections.EMPTY_LIST);

        // sorting columns labels
        Arrays.sort(columns, new Comparator<Object[]>() {
            @Override
            public int compare(Object[] o1, Object[] o2) {
                return Arrays.toString(o1).compareTo(Arrays.toString(o2));
            }
        });

        // sorting rows labels
        Arrays.sort(rows, new Comparator<Object[]>() {
            @Override
            public int compare(Object[] o1, Object[] o2) {
                return Arrays.toString(o1).compareTo(Arrays.toString(o2));
            }
        });

        // generates association of each of columns to an integer
        Map<ObjectArray, Integer> lookupColumns = generateLookup(columns);
        // generates association of each of rows to an integer
        Map<ObjectArray, Integer> lookupRows = generateLookup(rows);

        // generates the set of values (for every column X row) in order to aggregate it
        Map<Integer, Collection<Object>> values = extractValues(pivot, lookupColumns, lookupRows);

        fillValues(pivot, values, lookupColumns, lookupRows);
    }

    /**
     * extracts the values (one for each given field) from a
     * single data record and stores it in the set corresponding
     * to the given field
     * @param fields collection of field which values we want to extract
     * @param record data record that contains values for a given fields
     * @param sets map contains the set of values for a given fields. This 
     * map will be updated with new values after execution.
     */
    private void extractFieldsValues(Collection<? extends Field> fields, T record, Map<Field, Set<Object>> sets) {
        for (Field<?, T> f : fields) {
            if (!sets.containsKey(f)) {
                sets.put(f, new HashSet<>());
            }
            sets.get(f).add(f.getValue(record));
        }
    }

    /**
     * Generate all possible permutations of values for a given 
     * set of fields. If the addition is not an empty collection
     * its values will be included into the permutations.
     * @param fields a set of fields for which values we want to 
     * create permutations
     * @param sets the sets of values (one set for every field). If
     * it does not contains one of fields then the set of values for
     * this field will be empty
     * @param addition additional set of values inserted to permutations 
     * if needed
     * @return the array that contains resulted permutations (each record in
     * this array contains a permutation of values). The amount of records
     * in resulted array is MULT_{forall field in fields} (|values(field)|) * |addition|
     */
    private Object[][] permutateFieldsValues(Collection<? extends Field> fields, Map<Field, Set<Object>> sets, Collection addition) {
        Map<Field, Object[]> oAxis = new HashMap<>();
        Object[] oAdd = addition.toArray();

        for (Field f : fields) {
            if (!sets.containsKey(f)) {
                sets.put(f, new HashSet<>());
            }
            oAxis.put(f, sets.get(f).toArray());
        }

        int amountOfValues = 1, t = 0;
        int[] factors = new int[fields.size() + (oAdd.length == 0 ? 0 : 1)];

        for (Field f : fields) {
            factors[t++] = amountOfValues;
            amountOfValues *= oAxis.get(f).length;
        }

        if (oAdd.length != 0) {
            factors[t] = amountOfValues;
            amountOfValues *= oAdd.length;
        }

        Object[][] result = new Object[amountOfValues][];

        for (int i = 0; i < result.length; i++) {
            result[i] = new Object[factors.length];
            int j = 0;
            for (Field f : fields) {
                result[i][j] = oAxis.get(f)[(i / factors[j]) % oAxis.get(f).length];
                j++;
            }

            if (oAdd.length != 0) {
                result[i][j] = oAdd[(i / factors[j]) % oAdd.length];
            }
        }

        return result;
    }

    /**
     * generates association of every record in records with an integer
     * for future fast search
     * @param records a set of records for which we want to create association
     * @return association between records and integers
     */
    private Map<ObjectArray, Integer> generateLookup(Object[][] records) {
        Map<ObjectArray, Integer> res = new HashMap<>();

        for (int i = 0; i < records.length; i++) {
            res.put(new ObjectArray(records[i]), i);
        }

        return res;
    }

    /**
     * extracts set of values for each cell of pivot table. We assume
     * that at least one value field is selected
     * @param pivot contains value fields
     * @param lookupColumns lookup for columns (data to index)
     * @param lookupRows lookup for rows (data to index)
     * @return the set of extracted values for each cell in pivot table
     */
    private Map<Integer, Collection<Object>> extractValues(Pivot<T> pivot, Map<ObjectArray, Integer> lookupColumns, Map<ObjectArray, Integer> lookupRows) {
        Map<Integer, Collection<Object>> res = new HashMap<>();

        for (T r : pivot.getDataRecords()) {
            if (isRestrictedRecord(pivot, r)) {
                continue;
            }

            for (AggregatedField v : pivot.getSelectedValuesFields()) {
                int column = getColumnIndex(r, pivot.getSelectedSeriesFields(), v, lookupColumns);
                int row = getRowIndex(r, pivot.getSelectedAxisFields(), lookupRows);
                int index = column * rows.length + row;

                if (!res.containsKey(index)) {
                    res.put(index, new LinkedList<>());
                }

                res.get(index).add(v.getValue(r));
            }
        }

        return res;
    }

    private int getColumnIndex(T r, Collection<Field> selectedFields, AggregatedField v, Map<ObjectArray, Integer> lookup) {
        Object[] res = new Object[selectedFields.size() + 1];
        int i = 0;

        for (Field f : selectedFields) {
            res[i++] = f.getValue(r);
        }

        res[i] = v;

        return lookup.get(new ObjectArray(res));
    }

    private int getRowIndex(T r, Collection<Field> selectedFields, Map<ObjectArray, Integer> lookup) {
        Object[] res = new Object[selectedFields.size()];
        int i = 0;

        for (Field f : selectedFields) {
            res[i++] = f.getValue(r);
        }

        return lookup.get(new ObjectArray(res));
    }

    /**
     * fills up the pivot table with aggregated values. We assume that at least
     * one value field is selected and it is a last element at each column
     * @param pivot
     * @param values
     * @param lookupColumns
     * @param lookupRows 
     */
    private void fillValues(Pivot<T> pivot, Map<Integer, Collection<Object>> values, Map<ObjectArray, Integer> lookupColumns, Map<ObjectArray, Integer> lookupRows) {
        data = new Object[columns.length][];

        for (int i = 0; i < columns.length; i++) {
            data[i] = new Object[rows.length];

            for (int j = 0; j < rows.length; j++) {
                int column = lookupColumns.get(new ObjectArray(columns[i]));
                int row = lookupRows.get(new ObjectArray(rows[j]));
                int index = column * rows.length + row;
                final Collection<Object> value = values.get(index);

                if (value == null) {
                    data[i][j] = null;
                } else {
                    data[i][j] = ((AggregatedField) columns[i][columns[i].length - 1]).getAggregationFunction().aggregate(value);
                }
            }
        }
    }

    @Override
    public String toString() {
        return "Columns: \n" + joinI(columns) + "\n" + "Rows: \n" + joinI(rows) + "Table: \n" + joinI(data) + "\n";
    }

    public String joinI(Object[][] c) {
        LinkedList<String> subRes = new LinkedList<>();

        for (Object[] i : c) {
            subRes.addLast(join(i) + ",\n");
        }

        return join(subRes);
    }

    public String join(Object[] c) {
        StringBuilder sb = new StringBuilder("{");
        for (Object s : c) {
            sb.append("" + s).append(", ");
        }
        if (sb.length() != 1) {
            sb.delete(sb.length() - 2, sb.length());
        }

        return sb.append("}").toString();
    }

    public String join(Iterable c) {
        StringBuilder sb = new StringBuilder("{");
        for (Object s : c) {
            sb.append("" + s).append(", ");
        }
        if (sb.length() != 1) {
            sb.delete(sb.length() - 2, sb.length());
        }

        return sb.append("}").toString();
    }

    private boolean isRestrictedRecord(Pivot<T> pivot, T r) {
        for (FilterField ff : pivot.getSelectedFilterFields()) {
            if (ff.getRestrictedValues().contains(ff.getValue(r))) {
                return true;
            }
        }
        return false;
    }

    private class ObjectArray {

        Object[] array;

        public ObjectArray(Object[] array) {
            this.array = array;
        }

        public Object[] getArray() {
            return array;
        }

        public void setArray(Object[] array) {
            this.array = array;
        }

        @Override
        public int hashCode() {
            int hash = 5;
            hash = 79 * hash + Arrays.deepHashCode(this.array);
            return hash;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            final ObjectArray other = (ObjectArray) obj;
            return Arrays.deepEquals(this.array, other.array);
        }
    }
}
